# JAVA垃圾回收相关
## 算法
#### 引用计数法
方法：当对象有引用时+1，失去引用时-1，为0时被清理。

特点：垃圾清理时速度快，计数在程序运行时就在监控，gc时只需要清理，因此造成的程序停顿时间短。但循环引用的对象无法被清理。
####标记清除算法
方法：想对象的引用关系当作数据结构图来处理，从根元素集合开始扫描起引用对象，当落单对象被扫描出来后进行内存的清理。

特点：解决了循环引用不能被收集的情况，但是因为时直接清理垃圾内存，没有进行内存的整理，会造成内存碎片（当有对象需要连续地址的大空间时，无法使用这部分内存，造成浪费）。
#### 标记整理算法
方法：比标记清除算法多了整理内存的过程，在gc过后，会移动对象，拼接成连续内存地址，并更新指针

特点：解决内存碎片的问题，但是增加了对指针的记录，一般需要句柄和句柄表来处理，适用于老年代

#### 复制算法
方法：有两个区，当S0区对象满时，出发标记清除，然后复制到S1区，时S0区成为空闲去，在分配对象时在S1区分配，循环往复。

特点：不会存在内存碎片，但需要多一块内存，需要进行复制操作。在切换的过程中，程序将停止执行。适用于新生代，垃圾对象多余存货对象。

#### 分代回收
方法：分为新生代，老年代和永久代（JAVA8中取消永久代，变为元数据）

特点：不同区域使用不同的算法

#### 分区算法
方法：将堆划分为连续的不同小区间，每个小区间独立使用，独立回收

特点：执行过程中对程序影响较轻，感觉不到停顿时间。

## 垃圾收集器
#### 串行收集器
新生代使用复制算法，老年代使用标记整理算法，是一个单线程的收集器，在工作的时候会将应用暂停，JVM参数-XX:+UserSerialGC开启
#### 并行回收器
也采用复制算法，是串行收集器的多线程版本，通常设置参数-XX:ParallelGCThreads与系统CPU数量相同，-XX:UseParNewOldGC:新生代开启，-XX:UseParallerOldGC:老年代开启
#### CMS回收器
使用多线程来扫描堆，基于标记清理算法，标记那些可以回收的对象进行回收，主要步骤有主要步骤有：初始标记、并发标记、预清理、重新标记、并发清除和并发重置。
#### G1回收器
整体基于标记整理算法，局部使用复制算法，都不会产生内存碎片，比较追求更少的程序停顿时间。 -XX:+UseG1GC开启
